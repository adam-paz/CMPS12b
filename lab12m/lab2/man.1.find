#Adam Paz
#apa10@ucsc.edu
FIND(1)                                                                FIND(1)



NNAAMMEE
       find - search for files in a directory hierarchy

SSYYNNOOPPSSIISS
       ffiinndd [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]

DDEESSCCRRIIPPTTIIOONN
       This  manual page documents the GNU version of ffiinndd.  GNU ffiinndd searches
       the directory tree rooted at each given file  name  by  evaluating  the
       given  expression  from left to right, according to the rules of prece-
       dence (see section OPERATORS), until the outcome  is  known  (the  left
       hand  side  is  false  for _a_n_d operations, true for _o_r), at which point
       ffiinndd moves on to the next file name.

       If you are using ffiinndd in an environment  where  security  is  important
       (for  example  if  you  are  using  it  to  search directories that are
       writable by other users), you should read the "Security Considerations"
       chapter  of  the findutils documentation, which is called FFiinnddiinngg FFiilleess
       and comes with findutils.   That document  also  includes  a  lot  more
       detail  and discussion than this manual page, so you may find it a more
       useful source of information.

OOPPTTIIOONNSS
       The --HH, --LL and --PP options control  the  treatment  of  symbolic  links.
       Command-line  arguments  following these are taken to be names of files
       or directories to be examined, up to the  first  argument  that  begins
       with  ‘-’, or the argument ‘(’ or ‘!’.  That argument and any following
       arguments are taken to be the  expression  describing  what  is  to  be
       searched  for.   If  no paths are given, the current directory is used.
       If no expression is given, the  expression  --pprriinntt  is  used  (but  you
       should probably consider using --pprriinntt00 instead, anyway).

       This  manual  page  talks  about  ‘options’ within the expression list.
       These options control the behaviour of ffiinndd but are  specified  immedi-
       ately after the last path name.  The five ‘real’ options --HH, --LL, --PP, --DD
       and --OO must appear before the first path name, if  at  all.   A  double
       dash ---- can also be used to signal that any remaining arguments are not
       options (though ensuring that all start points begin with  either  ‘./’
       or  ‘/’  is  generally  safer if you use wildcards in the list of start
       points).

       -P     Never follow symbolic links.  This  is  the  default  behaviour.
              When ffiinndd examines or prints information a file, and the file is
              a symbolic link, the information used shall be  taken  from  the
              properties of the symbolic link itself.


       -L     Follow symbolic links.  When ffiinndd examines or prints information
              about files, the information used shall be taken from the  prop-
              erties  of  the file to which the link points, not from the link
              itself (unless it is a broken symbolic link or ffiinndd is unable to
              examine  the file to which the link points).  Use of this option
              implies --nnoolleeaaff.  If you later use the --PP option,  --nnoolleeaaff  will
              still  be  in  effect.   If --LL is in effect and ffiinndd discovers a
              symbolic link to a subdirectory during its search, the subdirec-
              tory pointed to by the symbolic link will be searched.

              When the --LL option is in effect, the --ttyyppee predicate will always
              match against the type of the file that a symbolic  link  points
              to rather than the link itself (unless the symbolic link is bro-
              ken).  Using --LL causes the --llnnaammee and --iillnnaammee predicates  always
              to return false.


       -H     Do  not  follow symbolic links, except while processing the com-
              mand line arguments.  When ffiinndd examines or  prints  information
              about  files, the information used shall be taken from the prop-
              erties of the symbolic link itself.   The only exception to this
              behaviour is when a file specified on the command line is a sym-
              bolic link, and the link can be resolved.  For  that  situation,
              the  information  used is taken from whatever the link points to
              (that is, the link is followed).  The information about the link
              itself  is used as a fallback if the file pointed to by the sym-
              bolic link cannot be examined.  If --HH is in effect  and  one  of
              the  paths specified on the command line is a symbolic link to a
              directory, the contents  of  that  directory  will  be  examined
              (though of course -maxdepth 0 would prevent this).

       If more than one of --HH, --LL and --PP is specified, each overrides the oth-
       ers; the last one appearing on the command line takes effect.  Since it
       is  the  default,  the  --PP  option should be considered to be in effect
       unless either --HH or --LL is specified.

       GNU ffiinndd frequently stats files during the processing  of  the  command
       line itself, before any searching has begun.  These options also affect
       how those arguments are processed.  Specifically, there are a number of
       tests  that  compare files listed on the command line against a file we
       are currently considering.  In each case, the  file  specified  on  the
       command  line  will  have been examined and some of its properties will
       have been saved.  If the named file is in fact a symbolic link, and the
       --PP  option  is  in effect (or if neither --HH nor --LL were specified), the
       information used for the comparison will be taken from  the  properties
       of  the symbolic link.  Otherwise, it will be taken from the properties
       of the file the link points to.  If ffiinndd cannot follow  the  link  (for
       example  because it has insufficient privileges or the link points to a
       nonexistent file) the properties of the link itself will be used.

       When the --HH or --LL ooppttiioonnss aarree iinn eeffffeecctt,, aannyy ssyymmbboolliicc lliinnkkss  lliisstteedd  as
       the  argument of --nneewweerr will be dereferenced, and the timestamp will be
       taken from the file to which the symbolic link points.  The  same  con-
       sideration applies to --nneewweerrXXYY, --aanneewweerr and --ccnneewweerr.

       The  --ffoollllooww  option has a similar effect to --LL, though it takes effect
       at the point where it appears (that is, if --LL is not used  but  --ffoollllooww
       is, any symbolic links appearing after --ffoollllooww on the command line will
       be dereferenced, and those before it will not).


       -D debugoptions
              Print diagnostic information; this can be  helpful  to  diagnose
              problems  with why ffiinndd is not doing what you want.  The list of
              debug options should be comma separated.  Compatibility  of  the
              debug  options  is not guaranteed between releases of findutils.
              For a complete list of valid debug options, see  the  output  of
              ffiinndd --DD hheellpp.  Valid debug options include

              help   Explain the debugging options

              tree   Show  the  expression  tree in its original and optimised
                     form.

              stat   Print messages as files are examined with  the  ssttaatt  and
                     llssttaatt  system  calls.  The ffiinndd program tries to minimise
                     such calls.

              opt    Prints diagnostic information relating to  the  optimisa-
                     tion of the expression tree; see the -O option.

              rates  Prints a summary indicating how often each predicate suc-
                     ceeded or failed.

       -Olevel
              Enables query optimisation.   The ffiinndd program reorders tests to
              speed up execution while preserving the overall effect; that is,
              predicates with side effects are not reordered relative to  each
              other.   The  optimisations performed at each optimisation level
              are as follows.

              0      Equivalent to optimisation level 1.

              1      This is the default optimisation level and corresponds to
                     the  traditional behaviour.  Expressions are reordered so
                     that tests based only on the names of files (for  example
                     --nnaammee and --rreeggeexx) are performed first.

              2      Any  --ttyyppee  or --xxttyyppee tests are performed after any tests
                     based only on the names of files, but  before  any  tests
                     that  require information from the inode.  On many modern
                     versions of Unix, file types are  returned  by  rreeaaddddiirr(())
                     and so these predicates are faster to evaluate than pred-
                     icates which need to stat the file first.

              3      At this optimisation level,  the  full  cost-based  query
                     optimiser  is enabled.  The order of tests is modified so
                     that cheap (i.e. fast) tests are performed first and more
                     expensive ones are performed later, if necessary.  Within
                     each cost band, predicates are evaluated earlier or later
                     according  to  whether they are likely to succeed or not.
                     For --oo, predicates which are likely to succeed are evalu-
                     ated  earlier, and for --aa, predicates which are likely to
                     fail are evaluated earlier.

              The cost-based optimiser has a fixed  idea  of  how  likely  any
              given  test  is to succeed.  In some cases the probability takes
              account of the specific nature of the test (for example, --ttyyppee ff
              is  assumed  to  be  more  likely to succeed than --ttyyppee cc).  The
              cost-based optimiser is currently being evaluated.   If it  does
              not actually improve the performance of ffiinndd, it will be removed
              again.  Conversely, optimisations that  prove  to  be  reliable,
              robust and effective may be enabled at lower optimisation levels
              over time.  However, the default  behaviour  (i.e.  optimisation
              level  1)  will not be changed in the 4.3.x release series.  The
              findutils test suite runs all the tests on ffiinndd at each  optimi-
              sation level and ensures that the result is the same.


EEXXPPRREESSSSIIOONNSS
       The  expression  is  made up of options (which affect overall operation
       rather than the processing of a specific file, and always return true),
       tests  (which  return  a  true or false value), and actions (which have
       side effects and return a true or false value), all separated by opera-
       tors.  --aanndd is assumed where the operator is omitted.

       If the expression contains no actions other than --pprruunnee, --pprriinntt is per-
       formed on all files for which the expression is true.


   OOPPTTIIOONNSS
       All options always return true.   Except  for  --ddaayyssttaarrtt,  --ffoollllooww  and
       --rreeggeexxttyyppee,  the  options  affect  all tests, including tests specified
       before the option.  This is because the options are processed when  the
       command  line  is parsed, while the tests don’t do anything until files
       are examined.  The --ddaayyssttaarrtt, --ffoollllooww and --rreeggeexxttyyppee options  are  dif-
       ferent  in  this respect, and have an effect only on tests which appear
       later in the command line.  Therefore, for clarity, it is best to place
       them  at  the  beginning of the expression.  A warning is issued if you
       don’t do this.


       -d     A synonym for -depth, for compatibility  with  FreeBSD,  NetBSD,
              MacOS X and OpenBSD.


       -daystart
              Measure  times  (for  --aammiinn,  --aattiimmee,  --ccmmiinn, --ccttiimmee, --mmmmiinn, and
              --mmttiimmee) from the beginning of today rather than  from  24  hours
              ago.   This  option only affects tests which appear later on the
              command line.


       -depth Process each directory’s contents before the  directory  itself.
              The -delete action also implies --ddeepptthh.


       -follow
              Deprecated;  use  the  --LL  option instead.  Dereference symbolic
              links.  Implies --nnoolleeaaff.  The --ffoollllooww option affects only  those
              tests  which appear after it on the command line.  Unless the --HH
              or --LL option has been specified, the  position  of  the  --ffoollllooww
              option  changes the behaviour of the --nneewweerr predicate; any files
              listed as the argument of --nneewweerr will be  dereferenced  if  they
              are symbolic links.  The same consideration applies to --nneewweerrXXYY,
              --aanneewweerr and --ccnneewweerr.  Similarly, the --ttyyppee predicate will always
              match  against  the type of the file that a symbolic link points
              to rather than the link itself.  Using --ffoollllooww causes the --llnnaammee
              aanndd --iillnnaammee predicates always to return false.


       -help, --help
              Print a summary of the command-line usage of ffiinndd and exit.


       -ignore_readdir_race
              Normally,  ffiinndd will emit an error message when it fails to stat
              a file.  If you give this option and a file is  deleted  between
              the  time ffiinndd reads the name of the file from the directory and
              the time it tries to stat the file, no  error  message  will  be
              issued.    This also applies to files or directories whose names
              are given on the command line.  This option takes effect at  the
              time  the  command  line  is  read,  which means that you cannot
              search one part of the filesystem with this option on  and  part
              of  it  with  this  option off (if you need to do that, you will
              need to issue two ffiinndd commands instead, one with the option and
              one without it).


       -maxdepth _l_e_v_e_l_s
              Descend at most _l_e_v_e_l_s (a non-negative integer) levels of direc-
              tories below the command line arguments.  --mmaaxxddeepptthh 00
               means only apply the tests and  actions  to  the  command  line
              arguments.


       -mindepth _l_e_v_e_l_s
              Do  not apply any tests or actions at levels less than _l_e_v_e_l_s (a
              non-negative integer).  --mmiinnddeepptthh  11  means  process  all  files
              except the command line arguments.


       -mount Don’t  descend  directories  on other filesystems.  An alternate
              name for --xxddeevv, for compatibility with some  other  versions  of
              ffiinndd.


       -noignore_readdir_race
              Turns off the effect of --iiggnnoorree__rreeaaddddiirr__rraaccee.


       -noleaf
              Do  not  optimize  by  assuming that directories contain 2 fewer
              subdirectories than their  hard  link  count.   This  option  is
              needed  when  searching  filesystems that do not follow the Unix
              directory-link convention, such as CD-ROM or MS-DOS  filesystems
              or  AFS  volume  mount  points.  Each directory on a normal Unix
              filesystem has at least 2 hard  links:  its  name  and  its  ‘.’
              entry.   Additionally,  its  subdirectories (if any) each have a
              ‘..’  entry linked to that directory.  When ffiinndd is examining  a
              directory,  after it has statted 2 fewer subdirectories than the
              directory’s link count, it knows that the rest of the entries in
              the directory are non-directories (‘leaf’ files in the directory
              tree).  If only the files’ names need to be examined,  there  is
              no  need  to  stat  them;  this  gives a significant increase in
              search speed.


       -regextype _t_y_p_e
              Changes the regular expression syntax understood by  --rreeggeexx  and
              --iirreeggeexx tests which occur later on the command line.  Currently-
              implemented types are emacs (this is  the  default),  posix-awk,
              posix-basic, posix-egrep and posix-extended.


       -version, --version
              Print the ffiinndd version number and exit.


       -warn, -nowarn
              Turn  warning  messages on or off.  These warnings apply only to
              the command line usage, not to any conditions  that  ffiinndd  might
              encounter  when  it searches directories.  The default behaviour
              corresponds to --wwaarrnn if standard input is a tty, and to  --nnoowwaarrnn
              otherwise.


       -xautofs
              Don’t descend directories on autofs filesystems.


       -xdev  Don’t descend directories on other filesystems.


   TTEESSTTSS
       Some  tests,  for  example  --nneewweerrXXYY  and  --ssaammeeffiillee,  allow comparison
       between the file currently being examined and some reference file spec-
       ified  on the command line.  When these tests are used, the interpreta-
       tion of the reference file is determined by the options --HH, --LL  and  --PP
       and any previous --ffoollllooww, but the reference file is only examined once,
       at the time the command line is parsed.  If the reference  file  cannot
       be  examined  (for  example,  the ssttaatt(2) system call fails for it), an
       error message is issued, and ffiinndd exits with a nonzero status.

       Numeric arguments can be specified as

       _+_n     for greater than _n,

       _-_n     for less than _n,

       _n      for exactly _n.



       -amin _n
              File was last accessed _n minutes ago.


       -anewer _f_i_l_e
              File was last accessed more recently than _f_i_l_e was modified.  If
              _f_i_l_e is a symbolic link and the --HH option or the --LL option is in
              effect, the access time of the file it points to is always used.


       -atime _n
              File  was  last  accessed _n*24 hours ago.  When find figures out
              how many 24-hour periods ago the file  was  last  accessed,  any
              fractional part is ignored, so to match --aattiimmee ++11, a file has to
              have been accessed at least _t_w_o days ago.


       -cmin _n
              File’s status was last changed _n minutes ago.


       -cnewer _f_i_l_e
              File’s status was last changed more recently than _f_i_l_e was modi-
              fied.   If  _f_i_l_e  is a symbolic link and the --HH option or the --LL
              option is in effect, the  status-change  time  of  the  file  it
              points to is always used.


       -ctime _n
              File’s status was last changed _n*24 hours ago.  See the comments
              for --aattiimmee to understand how rounding affects the interpretation
              of file status change times.


       -empty File is empty and is either a regular file or a directory.


       -executable
              Matches  files  which  are  executable and directories which are
              searchable (in a file name resolution sense).  This  takes  into
              account  access  control  lists  and other permissions artefacts
              which the --ppeerrmm test  ignores.   This  test  makes  use  of  the
              aacccceessss(2) system call, and so can be fooled by NFS servers which
              do UID mapping (or root-squashing), since many systems implement
              aacccceessss(2)  in  the client’s kernel and so cannot make use of the
              UID mapping information held on the server.  Because  this  test
              is  based only on the result of the aacccceessss(2) system call, there
              is no guarantee that a file for which  this  test  succeeds  can
              actually be executed.


       -false Always false.


       -fstype _t_y_p_e
              File  is  on  a  filesystem  of type _t_y_p_e.  The valid filesystem
              types vary among different versions of Unix; an incomplete  list
              of filesystem types that are accepted on some version of Unix or
              another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K.   You  can
              use  --pprriinnttff  with  the  %F  directive  to see the types of your
              filesystems.


       -gid _n File’s numeric group ID is _n.


       -group _g_n_a_m_e
              File belongs to group _g_n_a_m_e (numeric group ID allowed).


       -ilname _p_a_t_t_e_r_n
              Like --llnnaammee, but the match  is  case  insensitive.   If  the  --LL
              option  or  the  --ffoollllooww  option is in effect, this test returns
              false unless the symbolic link is broken.


       -iname _p_a_t_t_e_r_n
              Like --nnaammee, but the match is case insensitive.  For example, the
              patterns  ‘fo*’  and  ‘F??’  match  the file names ‘Foo’, ‘FOO’,
              ‘foo’, ‘fOo’, etc.   In these patterns, unlike  filename  expan-
              sion  by  the shell, an initial ‘.’ can be matched by ‘*’.  That
              is, ffiinndd --nnaammee **bbaarr will match the file ‘.foobar’.   Please note
              that  you should quote patterns as a matter of course, otherwise
              the shell will expand any wildcard characters in them.


       -inum _n
              File has inode number _n.  It  is  normally  easier  to  use  the
              --ssaammeeffiillee test instead.


       -ipath _p_a_t_t_e_r_n
              Behaves  in  the same way as --iiwwhhoolleennaammee.  This option is depre-
              cated, so please do not use it.


       -iregex _p_a_t_t_e_r_n
              Like --rreeggeexx, but the match is case insensitive.


       -iwholename _p_a_t_t_e_r_n
              Like --wwhhoolleennaammee, but the match is case insensitive.


       -links _n
              File has _n links.


       -lname _p_a_t_t_e_r_n
              File is a symbolic link whose contents match shell pattern  _p_a_t_-
              _t_e_r_n.  The metacharacters do not treat ‘/’ or ‘.’ specially.  If
              the --LL option or the --ffoollllooww option  is  in  effect,  this  test
              returns false unless the symbolic link is broken.


       -mmin _n
              File’s data was last modified _n minutes ago.


       -mtime _n
              File’s  data was last modified _n*24 hours ago.  See the comments
              for --aattiimmee to understand how rounding affects the interpretation
              of file modification times.


       -name _p_a_t_t_e_r_n
              Base  of  file  name  (the  path  with  the  leading directories
              removed) matches  shell  pattern  _p_a_t_t_e_r_n.   The  metacharacters
              (‘*’,  ‘?’,  and ‘[]’) match a ‘.’ at the start of the base name
              (this is a change in findutils-4.2.2; see section STANDARDS CON-
              FORMANCE  below).  To ignore a directory and the files under it,
              use --pprruunnee; see an example in the description of --ppaatthh.   Braces
              are  not recognised as being special, despite the fact that some
              shells including Bash imbue braces with  a  special  meaning  in
              shell patterns.  The filename matching is performed with the use
              of the ffnnmmaattcchh(3) library function.   Don’t  forget  to  enclose
              the  pattern  in quotes in order to protect it from expansion by
              the shell.


       -newer _f_i_l_e
              File was modified more recently than _f_i_l_e.  If _f_i_l_e  is  a  sym-
              bolic  link and the --HH option or the --LL option is in effect, the
              modification time of the file it points to is always used.


       -newerXY _r_e_f_e_r_e_n_c_e
              Compares the timestamp of the current file with _r_e_f_e_r_e_n_c_e.   The
              _r_e_f_e_r_e_n_c_e  argument  is  normally the name of a file (and one of
              its timestamps is used for the comparison) but it may also be  a
              string  describing  an  absolute time.  _X and _Y are placeholders
              for other letters, and these letters select which time belonging
              to how _r_e_f_e_r_e_n_c_e is used for the comparison.

              a   The access time of the file _r_e_f_e_r_e_n_c_e
              B   The birth time of the file _r_e_f_e_r_e_n_c_e
              c   The inode status change time of _r_e_f_e_r_e_n_c_e
              m   The modification time of the file _r_e_f_e_r_e_n_c_e
              t   _r_e_f_e_r_e_n_c_e is interpreted directly as a time

              Some  combinations are invalid; for example, it is invalid for _X
              to be _t.  Some combinations are not implemented on all  systems;
              for example _B is not supported on all systems.  If an invalid or
              unsupported combination  of  _X_Y  is  specified,  a  fatal  error
              results.   Time  specifications are interpreted as for the argu-
              ment to the --dd option of GNU ddaattee.  If you try to use the  birth
              time  of  a  reference file, and the birth time cannot be deter-
              mined, a fatal error message results.  If  you  specify  a  test
              which  refers  to  the  birth time of files being examined, this
              test will fail for any files where the birth time is unknown.


       -nogroup
              No group corresponds to file’s numeric group ID.


       -nouser
              No user corresponds to file’s numeric user ID.


       -path _p_a_t_t_e_r_n
              File name matches shell pattern _p_a_t_t_e_r_n.  The metacharacters  do
              not treat ‘/’ or ‘.’ specially; so, for example,
                        find . -path "./sr*sc"
              will  print an entry for a directory called ‘./src/misc’ (if one
              exists).  To ignore a whole directory tree,  use  --pprruunnee  rather
              than  checking every file in the tree.  For example, to skip the
              directory ‘src/emacs’ and all files and  directories  under  it,
              and  print the names of the other files found, do something like
              this:
                        find . -path ./src/emacs -prune -o -print
              Note that the pattern match test applies to the whole file name,
              starting from one of the start points named on the command line.
              It would only make sense to use an absolute path  name  here  if
              the  relevant  start point is also an absolute path.  This means
              that this command will never match anything:
                        find bar -path /foo/bar/myfile -print
              The predicate --ppaatthh is also supported by HP-UX ffiinndd and will  be
              in a forthcoming version of the POSIX standard.


       -perm _m_o_d_e
              File’s  permission  bits  are  exactly _m_o_d_e (octal or symbolic).
              Since an exact match is required, if you want to use  this  form
              for  symbolic  modes,  you  may have to specify a rather complex
              mode string.  For example ‘-perm  g=w’  will  only  match  files
              which  have  mode 0020 (that is, ones for which group write per-
              mission is the only permission set).  It is more likely that you
              will want to use the ‘/’ or ‘-’ forms, for example ‘-perm -g=w’,
              which matches any file with group  write  permission.   See  the
              EEXXAAMMPPLLEESS section for some illustrative examples.


       -perm -_m_o_d_e
              All  of the permission bits _m_o_d_e are set for the file.  Symbolic
              modes are accepted in this form, and this is usually the way  in
              which  would want to use them.  You must specify ‘u’, ‘g’ or ‘o’
              if you use a symbolic mode.   See the EEXXAAMMPPLLEESS section for  some
              illustrative examples.


       -perm /_m_o_d_e
              Any  of the permission bits _m_o_d_e are set for the file.  Symbolic
              modes are accepted in this form.  You must specify ‘u’,  ‘g’  or
              ‘o’  if  you  use a symbolic mode.  See the EEXXAAMMPPLLEESS section for
              some illustrative examples.  If no permission bits in  _m_o_d_e  are
              set,  this test matches any file (the idea here is to be consis-
              tent with the behaviour of --ppeerrmm --000000).


       -perm +_m_o_d_e
              Deprecated, old way of searching for files with any of the  per-
              mission  bits  in _m_o_d_e set.  You should use --ppeerrmm _/_m_o_d_e instead.
              Trying to use the ‘+’ syntax with symbolic modes will yield sur-
              prising  results.   For example, ‘+u+x’ is a valid symbolic mode
              (equivalent to +u,+x, i.e. 0111) and will therefore not be eval-
              uated  as  --ppeerrmm  ++_m_o_d_e  but instead as the exact mode specifier
              --ppeerrmm _m_o_d_e and so it matches files with exact  permissions  0111
              instead  of  files  with any execute bit set.  If you found this
              paragraph confusing, you’re not alone - just  use  --ppeerrmm  //_m_o_d_e.
              This  form  of  the  --ppeerrmm  test is deprecated because the POSIX
              specification requires the interpretation of a  leading  ‘+’  as
              being  part  of a symbolic mode, and so we switched to using ‘/’
              instead.


       -readable
              Matches files which  are  readable.   This  takes  into  account
              access  control  lists and other permissions artefacts which the
              --ppeerrmm test ignores.  This test makes use of the aacccceessss(2) system
              call,  and  so can be fooled by NFS servers which do UID mapping
              (or root-squashing), since many systems implement  aacccceessss(2)  in
              the  client’s  kernel  and so cannot make use of the UID mapping
              information held on the server.


       -regex _p_a_t_t_e_r_n
              File name matches regular expression _p_a_t_t_e_r_n.  This is  a  match
              on  the  whole path, not a search.  For example, to match a file
              named ‘./fubar3’, you can use the regular expression ‘.*bar.’ or
              ‘.*b.*3’,  but  not ‘f.*r3’.  The regular expressions understood
              by ffiinndd are by default Emacs Regular Expressions, but  this  can
              be changed with the --rreeggeexxttyyppee option.


       -samefile _n_a_m_e
              File  refers  to the same inode as _n_a_m_e.   When --LL is in effect,
              this can include symbolic links.


       -size _n[cwbkMG]
              File uses _n units of space.  The following suffixes can be used:

              ‘b’    for  512-byte blocks (this is the default if no suffix is
                     used)

              ‘c’    for bytes

              ‘w’    for two-byte words

              ‘k’    for Kilobytes (units of 1024 bytes)

              ‘M’    for Megabytes (units of 1048576 bytes)

              ‘G’    for Gigabytes (units of 1073741824 bytes)

              The size does not count  indirect  blocks,  but  it  does  count
              blocks in sparse files that are not actually allocated.  Bear in
              mind that the ‘%k’ and ‘%b’ format specifiers of --pprriinnttff  handle
              sparse   files  differently.   The  ‘b’  suffix  always  denotes
              512-byte blocks and never 1 Kilobyte blocks, which is  different
              to the behaviour of --llss.


       -true  Always true.


       -type _c
              File is of type _c:

              b      block (buffered) special

              c      character (unbuffered) special

              d      directory

              p      named pipe (FIFO)

              f      regular file

              l      symbolic link; this is never true if the --LL option or the
                     --ffoollllooww option is in effect, unless the symbolic link  is
                     broken.  If you want to search for symbolic links when --LL
                     is in effect, use --xxttyyppee.

              s      socket

              D      door (Solaris)

       -uid _n File’s numeric user ID is _n.


       -used _n
              File was last accessed _n days after its status was last changed.


       -user _u_n_a_m_e
              File is owned by user _u_n_a_m_e (numeric user ID allowed).


       -wholename _p_a_t_t_e_r_n
              See -path.    This alternative is less portable than --ppaatthh.


       -writable
              Matches  files  which  are  writable.   This  takes into account
              access control lists and other permissions artefacts  which  the
              --ppeerrmm test ignores.  This test makes use of the aacccceessss(2) system
              call, and so can be fooled by NFS servers which do  UID  mapping
              (or  root-squashing),  since many systems implement aacccceessss(2) in
              the client’s kernel and so cannot make use of  the  UID  mapping
              information held on the server.


       -xtype _c
              The  same as --ttyyppee unless the file is a symbolic link.  For sym-
              bolic links: if the --HH or --PP option was specified, true  if  the
              file  is  a  link to a file of type _c; if the --LL option has been
              given, true if _c is ‘l’.  In other words,  for  symbolic  links,
              --xxttyyppee checks the type of the file that --ttyyppee does not check.

       -context _p_a_t_t_e_r_n
              (SELinux  only)  Security  context of the file matches glob _p_a_t_-
              _t_e_r_n.


   AACCTTIIOONNSS
       -delete
              Delete files; true if removal succeeded.  If the removal failed,
              an  error message is issued.  If --ddeelleettee fails, ffiinndd’s exit sta-
              tus will be nonzero (when it eventually exits).  Use of  --ddeelleettee
              automatically turns on the ‘--ddeepptthh’ option.

              WWaarrnniinnggss:  Don’t  forget that the find command line is evaluated
              as an expression, so putting --ddeelleettee first will make ffiinndd try to
              delete everything below the starting points you specified.  When
              testing a ffiinndd command line that you later intend  to  use  with
              --ddeelleettee,  you should explicitly specify --ddeepptthh in order to avoid
              later surprises.  Because --ddeelleettee  implies  --ddeepptthh,  you  cannot
              usefully use --pprruunnee and --ddeelleettee together.


       -exec _c_o_m_m_a_n_d ;
              Execute  _c_o_m_m_a_n_d;  true  if 0 status is returned.  All following
              arguments to ffiinndd are taken to be arguments to the command until
              an  argument  consisting of ‘;’ is encountered.  The string ‘{}’
              is replaced by the current file name being processed  everywhere
              it occurs in the arguments to the command, not just in arguments
              where it is alone, as in some versions of ffiinndd.  Both  of  these
              constructions might need to be escaped (with a ‘\’) or quoted to
              protect them from expansion by the shell.  See the EEXXAAMMPPLLEESS sec-
              tion for examples of the use of the --eexxeecc option.  The specified
              command is run once for each matched file.  The command is  exe-
              cuted  in  the starting directory.   There are unavoidable secu-
              rity problems surrounding use of the --eexxeecc  action;  you  should
              use the --eexxeeccddiirr option instead.


       -exec _c_o_m_m_a_n_d {} +
              This  variant  of the --eexxeecc action runs the specified command on
              the selected files, but the command line is built  by  appending
              each  selected file name at the end; the total number of invoca-
              tions of the command will  be  much  less  than  the  number  of
              matched  files.   The command line is built in much the same way
              that xxaarrggss builds its command lines.  Only one instance of  ‘{}’
              is  allowed  within the command.  The command is executed in the
              starting directory.


       -execdir _c_o_m_m_a_n_d ;

       -execdir _c_o_m_m_a_n_d {} +
              Like --eexxeecc, but the specified command is run from the  subdirec-
              tory  containing  the  matched  file,  which is not normally the
              directory in which you started ffiinndd.  This a  much  more  secure
              method  for invoking commands, as it avoids race conditions dur-
              ing resolution of the paths to the matched files.  As  with  the
              --eexxeecc action, the ‘+’ form of --eexxeeccddiirr will build a command line
              to process more than one matched file, but any given  invocation
              of _c_o_m_m_a_n_d will only list files that exist in the same subdirec-
              tory.  If you use this option, you must ensure that  your  $$PPAATTHH
              environment  variable  does  not  reference  ‘.’;  otherwise, an
              attacker can run any commands they like by leaving an  appropri-
              ately-named  file in a directory in which you will run --eexxeeccddiirr.
              The same applies to having entries in $$PPAATTHH which are  empty  or
              which are not absolute directory names.


       -fls _f_i_l_e
              True;  like --llss but write to _f_i_l_e like --ffpprriinntt.  The output file
              is always created, even if the predicate is never matched.   See
              the  UUNNUUSSUUAALL FFIILLEENNAAMMEESS section for information about how unusual
              characters in filenames are handled.


       -fprint _f_i_l_e
              True; print the full file name into file _f_i_l_e.  If _f_i_l_e does not
              exist  when  ffiinndd is run, it is created; if it does exist, it is
              truncated.  The file names ‘/dev/stdout’ and  ‘/dev/stderr’  are
              handled  specially;  they refer to the standard output and stan-
              dard error output, respectively.  The output file is always cre-
              ated,  even  if the predicate is never matched.  See the UUNNUUSSUUAALL
              FFIILLEENNAAMMEESS section for information about how  unusual  characters
              in filenames are handled.


       -fprint0 _f_i_l_e
              True;  like  --pprriinntt00 but write to _f_i_l_e like --ffpprriinntt.  The output
              file is always created, even if the predicate is never  matched.
              See  the  UUNNUUSSUUAALL  FFIILLEENNAAMMEESS  section  for information about how
              unusual characters in filenames are handled.


       -fprintf _f_i_l_e _f_o_r_m_a_t
              True; like --pprriinnttff but write to _f_i_l_e like --ffpprriinntt.   The  output
              file  is always created, even if the predicate is never matched.
              See the UUNNUUSSUUAALL FFIILLEENNAAMMEESS  section  for  information  about  how
              unusual characters in filenames are handled.


       -ls    True;  list  current file in llss --ddiillss format on standard output.
              The block counts are of 1K blocks, unless the environment  vari-
              able  POSIXLY_CORRECT  is set, in which case 512-byte blocks are
              used.  See the UUNNUUSSUUAALL FFIILLEENNAAMMEESS section for  information  about
              how unusual characters in filenames are handled.


       -ok _c_o_m_m_a_n_d ;
              Like  --eexxeecc but ask the user first.  If the user agrees, run the
              command.  Otherwise just return false.  If the command  is  run,
              its standard input is redirected from //ddeevv//nnuullll.


              The  response to the prompt is matched against a pair of regular
              expressions to determine if it is  an  affirmative  or  negative
              response.   This  regular expression is obtained from the system
              if the ‘POSIXLY_CORRECT’ environment variable is set, or  other-
              wise  from  ffiinndd’s  message  translations.  If the system has no
              suitable definition, ffiinndd’s own definition will  be  used.    In
              either case, the interpretation of the regular expression itself
              will be affected by the environment variables ’LC_CTYPE’  (char-
              acter  classes)  and  ’LC_COLLATE’ (character ranges and equiva-
              lence classes).




       -okdir _c_o_m_m_a_n_d ;
              Like --eexxeeccddiirr but ask the user first in the same way as for --ookk.
              If  the  user does not agree, just return false.  If the command
              is run, its standard input is redirected from //ddeevv//nnuullll.


       -print True; print the full file name on the standard output,  followed
              by  a  newline.    If  you  are  piping  the output of ffiinndd into
              another program and there is the faintest possibility  that  the
              files  which you are searching for might contain a newline, then
              you should seriously consider using the --pprriinntt00  option  instead
              of  --pprriinntt.   See  the UUNNUUSSUUAALL FFIILLEENNAAMMEESS section for information
              about how unusual characters in filenames are handled.


       -print0
              True; print the full file name on the standard output,  followed
              by  a  null  character  (instead  of  the newline character that
              --pprriinntt uses).  This allows file names that contain  newlines  or
              other  types  of white space to be correctly interpreted by pro-
              grams that process the ffiinndd output.  This option corresponds  to
              the --00 option of xxaarrggss.


       -printf _f_o_r_m_a_t
              True;  print  _f_o_r_m_a_t  on  the  standard output, interpreting ‘\’
              escapes and ‘%’ directives.  Field widths and precisions can  be
              specified  as  with  the  ‘printf’ C function.  Please note that
              many of the fields are printed as %s rather than  %d,  and  this
              may  mean  that flags don’t work as you might expect.  This also
              means that the ‘-’ flag does work (it forces fields to be  left-
              aligned).   Unlike --pprriinntt, --pprriinnttff does not add a newline at the
              end of the string.  The escapes and directives are:

              \a     Alarm bell.

              \b     Backspace.

              \c     Stop printing from this format immediately and flush  the
                     output.

              \f     Form feed.

              \n     Newline.

              \r     Carriage return.

              \t     Horizontal tab.

              \v     Vertical tab.

              \0     ASCII NUL.

              \\     A literal backslash (‘\’).

              \NNN   The character whose ASCII code is NNN (octal).

              A ‘\’ character followed by any other character is treated as an
              ordinary character, so they both are printed.

              %%     A literal percent sign.

              %a     File’s last access time in the format returned by  the  C
                     ‘ctime’ function.

              %A_k    File’s  last  access  time  in the format specified by _k,
                     which is either ‘@’ or a directive for the  C  ‘strftime’
                     function.   The  possible  values for _k are listed below;
                     some of them might not be available on all  systems,  due
                     to differences in ‘strftime’ between systems.

                      @      seconds since Jan. 1, 1970, 00:00 GMT, with frac-
                             tional part.

                     Time fields:

                      H      hour (00..23)

                      I      hour (01..12)

                      k      hour ( 0..23)

                      l      hour ( 1..12)

                      M      minute (00..59)

                      p      locale’s AM or PM

                      r      time, 12-hour (hh:mm:ss [AP]M)

                      S      Second (00.00 .. 61.00).  There is  a  fractional
                             part.

                      T      time, 24-hour (hh:mm:ss)

                      +      Date  and  time,  separated  by  ‘+’, for example
                             ‘2004-04-28+22:22:05.0’.  This is  a  GNU  exten-
                             sion.   The time is given in the current timezone
                             (which may be affected by setting the TZ environ-
                             ment  variable).   The  seconds  field includes a
                             fractional part.

                      X      locale’s time representation (H:M:S)

                      Z      time zone (e.g., EDT), or nothing if no time zone
                             is determinable

                     Date fields:

                      a      locale’s abbreviated weekday name (Sun..Sat)

                      A      locale’s full weekday name, variable length (Sun-
                             day..Saturday)

                      b      locale’s abbreviated month name (Jan..Dec)

                      B      locale’s full month name, variable  length  (Jan-
                             uary..December)

                      c      locale’s  date  and time (Sat Nov 04 12:02:33 EST
                             1989).  The format is the same  as  for  ccttiimmee(3)
                             and  so  to preserve compatibility with that for-
                             mat, there is no fractional part in  the  seconds
                             field.

                      d      day of month (01..31)

                      D      date (mm/dd/yy)

                      h      same as b

                      j      day of year (001..366)

                      m      month (01..12)

                      U      week  number  of year with Sunday as first day of
                             week (00..53)

                      w      day of week (0..6)

                      W      week number of year with Monday as first  day  of
                             week (00..53)

                      x      locale’s date representation (mm/dd/yy)

                      y      last two digits of year (00..99)

                      Y      year (1970...)

              %b     The  amount  of disk space used for this file in 512-byte
                     blocks. Since disk space is allocated in multiples of the
                     filesystem  block  size  this  is  usually  greater  than
                     %s/512, but it can also be  smaller  if  the  file  is  a
                     sparse file.

              %c     File’s  last status change time in the format returned by
                     the C ‘ctime’ function.

              %C_k    File’s last status change time in the format specified by
                     _k, which is the same as for %A.

              %d     File’s depth in the directory tree; 0 means the file is a
                     command line argument.

              %D     The device number on which the file  exists  (the  st_dev
                     field of struct stat), in decimal.

              %f     File’s  name  with  any leading directories removed (only
                     the last element).

              %F     Type of the filesystem the file is on; this value can  be
                     used for -fstype.

              %g     File’s  group  name, or numeric group ID if the group has
                     no name.

              %G     File’s numeric group ID.

              %h     Leading directories of file’s name (all but the last ele-
                     ment).  If the file name contains no slashes (since it is
                     in the current directory) the  %h  specifier  expands  to
                     ".".

              %H     Command line argument under which file was found.

              %i     File’s inode number (in decimal).

              %k     The amount of disk space used for this file in 1K blocks.
                     Since  disk  space  is  allocated  in  multiples  of  the
                     filesystem  block  size  this  is  usually  greater  than
                     %s/1024, but it can also be smaller  if  the  file  is  a
                     sparse file.

              %l     Object  of  symbolic  link (empty string if file is not a
                     symbolic link).

              %m     File’s permission bits (in octal).  This option uses  the
                     ‘traditional’  numbers  which  most  Unix implementations
                     use,  but  if  your  particular  implementation  uses  an
                     unusual  ordering of octal permissions bits, you will see
                     a difference between the actual value of the file’s  mode
                     and  the output of %m.   Normally you will want to have a
                     leading zero on this number, and to do this,  you  should
                     use the ## flag (as in, for example, ‘%#m’).

              %M     File’s  permissions  (in symbolic form, as for llss).  This
                     directive is supported in findutils 4.2.5 and later.

              %n     Number of hard links to file.

              %p     File’s name.

              %P     File’s name with the name of the  command  line  argument
                     under which it was found removed.

              %s     File’s size in bytes.

              %S     File’s   sparseness.    This  is  calculated  as  (BLOCK-
                     SIZE*st_blocks / st_size).  The exact value you will  get
                     for an ordinary file of a certain length is system-depen-
                     dent.  However, normally sparse files  will  have  values
                     less  than  1.0,  and files which use indirect blocks may
                     have a value which is greater than 1.0.   The value  used
                     for  BLOCKSIZE  is  system-dependent,  but is usually 512
                     bytes.   If the file size is zero, the value  printed  is
                     undefined.   On systems which lack support for st_blocks,
                     a file’s sparseness is assumed to be 1.0.

              %t     File’s last modification time in the format  returned  by
                     the C ‘ctime’ function.

              %T_k    File’s  last modification time in the format specified by
                     _k, which is the same as for %A.

              %u     File’s user name, or numeric user ID if the user  has  no
                     name.

              %U     File’s numeric user ID.

              %y     File’s  type  (like  in llss --ll), U=unknown type (shouldn’t
                     happen)

              %Y     File’s type (like  %y),  plus  follow  symlinks:  L=loop,
                     N=nonexistent

              %Z     (SELinux only) file’s security context.

              A  ‘%’  character  followed by any other character is discarded,
              but the other character is printed (don’t rely on this, as  fur-
              ther  format characters may be introduced).  A ‘%’ at the end of
              the format argument causes undefined behaviour since there is no
              following  character.   In  some  locales, it may hide your door
              keys, while in others it may remove  the  final  page  from  the
              novel you are reading.

              The  %m and %d directives support the ## , 00 and ++ flags, but the
              other directives do not, even if they  print  numbers.   Numeric
              directives that do not support these flags include GG, UU, bb, DD, kk
              and nn.  The ‘-’ format flag is supported and changes the  align-
              ment  of  a field from right-justified (which is the default) to
              left-justified.

              See the UUNNUUSSUUAALL FFIILLEENNAAMMEESS  section  for  information  about  how
              unusual characters in filenames are handled.



       -prune True;  if  the  file  is a directory, do not descend into it. If
              --ddeepptthh is given, false;  no  effect.   Because  --ddeelleettee  implies
              --ddeepptthh, you cannot usefully use --pprruunnee and --ddeelleettee ttooggeetthheerr..


       -quit  Exit  immediately.  No child processes will be left running, but
              no more paths specified on the command line will  be  processed.
              For example, ffiinndd //ttmmpp//ffoooo //ttmmpp//bbaarr --pprriinntt --qquuiitt will print only
              //ttmmpp//ffoooo.  Any command lines  which  have  been  built  up  with
              --eexxeeccddiirr  ...... {{}} ++ will be invoked before ffiinndd exits.   The exit
              status may or may not be zero, depending on whether an error has
              already occurred.


   UUNNUUSSUUAALL FFIILLEENNAAMMEESS
       Many  of  the  actions  of ffiinndd result in the printing of data which is
       under the control of other users.  This  includes  file  names,  sizes,
       modification  times  and  so forth.  File names are a potential problem
       since they can contain any character  except  ‘\0’  and  ‘/’.   Unusual
       characters in file names can do unexpected and often undesirable things
       to your terminal (for example, changing the settings of  your  function
       keys on some terminals).  Unusual characters are handled differently by
       various actions, as described below.


       -print0, -fprint0
              Always print the exact filename, unchanged, even if  the  output
              is going to a terminal.


       -ls, -fls
              Unusual  characters are always escaped.  White space, backslash,
              and double quote characters are printed using  C-style  escaping
              (for  example ‘\f’, ‘\"’).  Other unusual characters are printed
              using an octal escape.  Other printable characters (for --llss  and
              --ffllss  these  are  the characters between octal 041 and 0176) are
              printed as-is.


       -printf, -fprintf
              If the output is not going to a terminal, it is  printed  as-is.
              Otherwise, the result depends on which directive is in use.  The
              directives %D, %F, %g, %G, %H, %Y, and %y expand to values which
              are  not  under control of files’ owners, and so are printed as-
              is.  The directives %a, %b, %c, %d, %i, %k, %m, %M, %n, %s,  %t,
              %u and %U have values which are under the control of files’ own-
              ers but which cannot be used to send arbitrary data to the  ter-
              minal,  and  so these are printed as-is.  The directives %f, %h,
              %l, %p and %P are quoted.  This quoting is performed in the same
              way  as  for  GNU llss.  This is not the same quoting mechanism as
              the one used for --llss and --ffllss.  If you are able to  decide  what
              format  to use for the output of ffiinndd then it is normally better
              to use ‘\0’ as a terminator than to use newline, as  file  names
              can  contain white space and newline characters.  The setting of
              the ‘LC_CTYPE’ environment variable is used to  determine  which
              characters need to be quoted.


       -print, -fprint
              Quoting  is handled in the same way as for --pprriinnttff and --ffpprriinnttff.
              If you are using ffiinndd in a script or in a  situation  where  the
              matched  files  might  have arbitrary names, you should consider
              using --pprriinntt00 instead of --pprriinntt.

       The --ookk and --ookkddiirr actions print the current filename as-is.  This  may
       change in a future release.


   OOPPEERRAATTOORRSS
       Listed in order of decreasing precedence:


       ( _e_x_p_r )
              Force  precedence.   Since parentheses are special to the shell,
              you will normally need to quote them.  Many of the  examples  in
              this  manual  page  use  backslashes for this purpose: ‘\(...\)’
              instead of ‘(...)’.


       ! _e_x_p_r True if _e_x_p_r is false.  This character will  also  usually  need
              protection from interpretation by the shell.


       -not _e_x_p_r
              Same as ! _e_x_p_r, but not POSIX compliant.


       _e_x_p_r_1 _e_x_p_r_2
              Two  expressions in a row are taken to be joined with an implied
              "and"; _e_x_p_r_2 is not evaluated if _e_x_p_r_1 is false.


       _e_x_p_r_1 -a _e_x_p_r_2
              Same as _e_x_p_r_1 _e_x_p_r_2.


       _e_x_p_r_1 -and _e_x_p_r_2
              Same as _e_x_p_r_1 _e_x_p_r_2, but not POSIX compliant.


       _e_x_p_r_1 -o _e_x_p_r_2
              Or; _e_x_p_r_2 is not evaluated if _e_x_p_r_1 is true.


       _e_x_p_r_1 -or _e_x_p_r_2
              Same as _e_x_p_r_1 --oo _e_x_p_r_2, but not POSIX compliant.


       _e_x_p_r_1 , _e_x_p_r_2
              List; both _e_x_p_r_1 and _e_x_p_r_2 are always evaluated.  The  value  of
              _e_x_p_r_1 is discarded; the value of the list is the value of _e_x_p_r_2.
              The comma operator can be useful for searching for several  dif-
              ferent  types  of thing, but traversing the filesystem hierarchy
              only once.  The --ffpprriinnttff action can be used to list the  various
              matched items into several different output files.



SSTTAANNDDAARRDDSS CCOONNFFOORRMMAANNCCEE
       For  closest  compliance  to  the  POSIX  standard,  you should set the
       POSIXLY_CORRECT environment variable.  The following options are speci-
       fied in the POSIX standard (IEEE Std 1003.1, 2003 Edition):


       --HH     This option is supported.


       --LL     This option is supported.


       --nnaammee  This  option  is supported, but POSIX conformance depends on the
              POSIX conformance of the system’s ffnnmmaattcchh(3)  library  function.
              As  of  findutils-4.2.2,  shell metacharacters (‘*’, ‘?’ or ‘[]’
              for example) will match a leading ‘.’, because IEEE PASC  inter-
              pretation  126  requires  this.   This is a change from previous
              versions of findutils.


       --ttyyppee  Supported.   POSIX specifies ‘b’, ‘c’, ‘d’, ‘l’,  ‘p’,  ‘f’  and
              ‘s’.  GNU find also supports ‘D’, representing a Door, where the
              OS provides these.


       --ookk    Supported.  Interpretation of the response is according  to  the
              "yes"  and  "no"  patterns selected by setting the ‘LC_MESSAGES’
              environment variable.  When  the  ‘POSIXLY_CORRECT’  environment
              variable is set, these patterns are taken system’s definition of
              a positive (yes) or negative (no)  response.  See  the  system’s
              documentation  for  nnll__llaannggiinnffoo(3),  in  particular  YESEXPR and
              NOEXPR.    When ‘POSIXLY_CORRECT’ is not set, the  patterns  are
              instead taken from ffiinndd’s own message catalogue.


       --nneewweerr Supported.   If  the  file  specified  is a symbolic link, it is
              always dereferenced.  This is a change from previous  behaviour,
              which used to take the relevant time from the symbolic link; see
              the HISTORY section below.


       --ppeerrmm  Supported.  If the POSIXLY_CORRECT environment variable  is  not
              set,  some mode arguments (for example +a+x) which are not valid
              in POSIX are supported for backward-compatibility.


       Other predicates
              The predicates --aattiimmee, --ccttiimmee, --ddeepptthh, --ggrroouupp,  --lliinnkkss,  --mmttiimmee,
              --nnooggrroouupp,  --nnoouusseerr,  --pprriinntt,  --pprruunnee,  --ssiizzee,  --uusseerr  and  --xxddeevv
              ‘-atime’,  ‘-ctime’,  ‘-depth’,  ‘-group’,  ‘-links’,  ‘-mtime’,
              ‘-nogroup’,  ‘-nouser’,  ‘-perm’,  ‘-print’,  ‘-prune’, ‘-size’,
              ‘-user’ and ‘-xdev’ are all supported.


       The POSIX standard specifies parentheses ‘(’, ‘)’, negation ‘!’ and the
       ‘and’ and ‘or’ operators ( --aa, --oo).

       All  other options, predicates, expressions and so forth are extensions
       beyond the POSIX standard.  Many of these extensions are not unique  to
       GNU find, however.

       The POSIX standard requires that ffiinndd detects loops:

              The  ffiinndd utility shall detect infinite loops; that is, entering
              a previously visited directory that is an ancestor of  the  last
              file  encountered.  When it detects an infinite loop, find shall
              write a diagnostic message to standard error  and  shall  either
              recover its position in the hierarchy or terminate.

       GNU  ffiinndd complies with these requirements.  The link count of directo-
       ries which contain entries which are hard links  to  an  ancestor  will
       often  be  lower than they otherwise should be.  This can mean that GNU
       find will sometimes optimise away the visiting of a subdirectory  which
       is  actually a link to an ancestor.  Since ffiinndd does not actually enter
       such a subdirectory, it is allowed to avoid emitting a diagnostic  mes-
       sage.   Although  this  behaviour  may  be  somewhat  confusing,  it is
       unlikely that anybody actually depends on this behaviour.  If the  leaf
       optimisation has been turned off with --nnoolleeaaff, the directory entry will
       always be examined and the diagnostic message will be issued  where  it
       is  appropriate.   Symbolic  links  cannot be used to create filesystem
       cycles as such, but if the --LL option or the --ffoollllooww option is in use, a
       diagnostic  message  is  issued when ffiinndd encounters a loop of symbolic
       links.  As with loops containing hard links, the leaf optimisation will
       often  mean  that  ffiinndd  knows  that  it doesn’t need to call _s_t_a_t_(_) or
       _c_h_d_i_r_(_) on the symbolic link, so this diagnostic is frequently not nec-
       essary.

       The  --dd option is supported for compatibility with various BSD systems,
       but you should use the POSIX-compliant option --ddeepptthh instead.

       The POSIXLY_CORRECT environment variable does not affect the  behaviour
       of  the --rreeggeexx or --iirreeggeexx tests because those tests aren’t specified in
       the POSIX standard.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       LANG   Provides a default value for the internationalization  variables
              that are unset or null.


       LC_ALL If  set  to a non-empty string value, override the values of all
              the other internationalization variables.


       LC_COLLATE
              The POSIX standard specifies that this variable affects the pat-
              tern  matching  to be used for the --nnaammee option.   GNU find uses
              the ffnnmmaattcchh(3) library function, and so support for ‘LC_COLLATE’
              depends on the system library.    This variable also affects the
              interpretation of the response to --ookk;; while  the  ‘LC_MESSAGES’
              variable  selects  the  actual  pattern  used  to  interpret the
              response to --ookk, the interpretation of any  bracket  expressions
              in the pattern will be affected by ‘LC_COLLATE’.


       LC_CTYPE
              This variable affects the treatment of character classes used in
              regular expressions and also with the --nnaammee test,  if  the  sys-
              tem’s  ffnnmmaattcchh(3) library function supports this.  This variable
              also affects the interpretation of any character classes in  the
              regular expressions used to interpret the response to the prompt
              issued by --ookk.  The ‘LC_CTYPE’ environment  variable  will  also
              affect  which  characters  are considered to be unprintable when
              filenames are printed; see the section UNUSUAL FILENAMES.


       LC_MESSAGES
              Determines the locale to be used for internationalised messages.
              If  the ‘POSIXLY_CORRECT’ environment variable is set, this also
              determines the interpretation of the response to the prompt made
              by the --ookk action.


       NLSPATH
              Determines the location of the internationalisation message cat-
              alogues.


       PATH   Affects the directories which are searched to find the  executa-
              bles invoked by --eexxeecc, --eexxeeccddiirr, --ookk and --ookkddiirr.


       POSIXLY_CORRECT
              Determines the block size used by --llss and --ffllss.  If PPOOSSIIXXLLYY__CCOORR--
              RREECCTT is set, blocks are units of 512 bytes.  Otherwise they  are
              units of 1024 bytes.

              Setting  this variable also turns off warning messages (that is,
              implies --nnoowwaarrnn) by default, because POSIX requires  that  apart
              from  the  output  for  --ookk,  all messages printed on stderr are
              diagnostics and must result in a non-zero exit status.

              When POSIXLY_CORRECT is not set, --ppeerrmm +zzz is treated just like
              --ppeerrmm  /zzz  if  +zzz  is  not  a  valid  symbolic  mode.   When
              POSIXLY_CORRECT is set, such constructs are treated as an error.

              When  POSIXLY_CORRECT is set, the response to the prompt made by
              the --ookk action is interpreted according to the system’s  message
              catalogue,  as opposed to according to ffiinndd’s own message trans-
              lations.


       TZ     Affects the time zone used for some of the  time-related  format
              directives of --pprriinnttff and --ffpprriinnttff.

EEXXAAMMPPLLEESS
       ffiinndd //ttmmpp --nnaammee ccoorree --ttyyppee ff --pprriinntt || xxaarrggss //bbiinn//rrmm --ff

       Find  files  named ccoorree in or below the directory //ttmmpp and delete them.
       Note that this will work incorrectly if there are  any  filenames  con-
       taining newlines, single or double quotes, or spaces.

       ffiinndd //ttmmpp --nnaammee ccoorree --ttyyppee ff --pprriinntt00 || xxaarrggss --00 //bbiinn//rrmm --ff

       Find  files  named ccoorree in or below the directory //ttmmpp and delete them,
       processing filenames in such a way that file or  directory  names  con-
       taining  single or double quotes, spaces or newlines are correctly han-
       dled.  The --nnaammee test comes before the --ttyyppee test  in  order  to  avoid
       having to call ssttaatt((22)) on every file.


       ffiinndd .. --ttyyppee ff --eexxeecc ffiillee ''{{}}'' \\;;

       Runs  ‘file’  on  every file in or below the current directory.  Notice
       that the braces are enclosed in single quote marks to protect them from
       interpretation as shell script punctuation.  The semicolon is similarly
       protected by the use of a backslash, though single  quotes  could  have
       been used in that case also.


       ffiinndd // \\(( --ppeerrmm --44000000 --ffpprriinnttff //rroooott//ssuuiidd..ttxxtt ''%%##mm %%uu %%pp\\nn'' \\)) ,, \\
       \\(( --ssiizzee ++110000MM --ffpprriinnttff //rroooott//bbiigg..ttxxtt ''%%--1100ss %%pp\\nn'' \\))

       Traverse the filesystem just once, listing setuid files and directories
       into //rroooott//ssuuiidd..ttxxtt and large files into //rroooott//bbiigg..ttxxtt.


       ffiinndd $$HHOOMMEE --mmttiimmee 00

       Search for files in your home directory which have been modified in the
       last  twenty-four  hours.  This command works this way because the time
       since each file was last modified  is  divided  by  24  hours  and  any
       remainder is discarded.  That means that to match --mmttiimmee 00, a file will
       have to have a modification in the past which is  less  than  24  hours
       ago.


       ffiinndd //ssbbiinn //uussrr//ssbbiinn --eexxeeccuuttaabbllee \\!! --rreeaaddaabbllee --pprriinntt

       Search for files which are executable but not readable.


       ffiinndd .. --ppeerrmm 666644

       Search  for files which have read and write permission for their owner,
       and group, but which other users can read  but  not  write  to.   Files
       which  meet  these  criteria  but  have other permissions bits set (for
       example if someone can execute the file) will not be matched.


       ffiinndd .. --ppeerrmm --666644

       Search for files which have read and write permission for  their  owner
       and  group, and which other users can read, without regard to the pres-
       ence of any extra permission bits (for  example  the  executable  bit).
       This will match a file which has mode 0777, for example.


       ffiinndd .. --ppeerrmm //222222

       Search  for files which are writable by somebody (their owner, or their
       group, or anybody else).


       ffiinndd .. --ppeerrmm //222200
       ffiinndd .. --ppeerrmm //uu++ww,,gg++ww
       ffiinndd .. --ppeerrmm //uu==ww,,gg==ww

       All three of these commands do the same thing, but the first  one  uses
       the  octal  representation  of the file mode, and the other two use the
       symbolic form.  These commands all search for files which are  writable
       by  either  their  owner  or  their  group.  The files don’t have to be
       writable by both the owner and group to be matched; either will do.


       ffiinndd .. --ppeerrmm --222200
       ffiinndd .. --ppeerrmm --gg++ww,,uu++ww

       Both these commands do the same  thing;  search  for  files  which  are
       writable by both their owner and their group.


       ffiinndd .. --ppeerrmm --444444 --ppeerrmm //222222 !! --ppeerrmm //111111
       ffiinndd .. --ppeerrmm --aa++rr --ppeerrmm //aa++ww !! --ppeerrmm //aa++xx

       These  two  commands both search for files that are readable for every-
       body ( --ppeerrmm --444444 or --ppeerrmm --aa++rr), have at least one  write  bit  set  (
       --ppeerrmm  //222222 or --ppeerrmm //aa++ww) but are not executable for anybody ( !! --ppeerrmm
       //111111 and !! --ppeerrmm //aa++xx respectively).


       ccdd //ssoouurrccee--ddiirr
       ffiinndd .. --nnaammee ..ssnnaappsshhoott --pprruunnee --oo \\(( \\!! --nnaammee **~~ --pprriinntt00 \\))||
       ccppiioo --ppmmdd00 //ddeesstt--ddiirr

       This command copies the contents of //ssoouurrccee--ddiirr to //ddeesstt--ddiirr, but omits
       files  and directories named ..ssnnaappsshhoott (and anything in them).  It also
       omits files or directories whose name ends in ~~,  but  not  their  con-
       tents.  The construct --pprruunnee --oo \\(( ...... --pprriinntt00 \\)) is quite common.  The
       idea here is that the expression before --pprruunnee matches things which are
       to  be  pruned.  However, the --pprruunnee action itself returns true, so the
       following --oo ensures that the right hand side  is  evaluated  only  for
       those  directories  which didn’t get pruned (the contents of the pruned
       directories are not even visited, so their  contents  are  irrelevant).
       The  expression on the right hand side of the --oo is in parentheses only
       for clarity.  It emphasises that the --pprriinntt00 action  takes  place  only
       for  things  that  didn’t  have  --pprruunnee  applied  to them.  Because the
       default ‘and’ condition between tests binds more tightly than --oo,  this
       is  the  default anyway, but the parentheses help to show what is going
       on.


       ffiinndd rreeppoo// --eexxeecc tteesstt --dd {{}}//..ssvvnn --oo --dd {{}}//..ggiitt --oo --dd {{}}//CCVVSS ;; \\
       --pprriinntt --pprruunnee

       Given the following directory of  projects  and  their  associated  SCM
       administrative   directories,  perform  an  efficient  search  for  the
       projects’ roots:

       rreeppoo//pprroojjeecctt11//CCVVSS
       rreeppoo//ggnnuu//pprroojjeecctt22//..ssvvnn
       rreeppoo//ggnnuu//pprroojjeecctt33//..ssvvnn
       rreeppoo//ggnnuu//pprroojjeecctt33//ssrrcc//..ssvvnn
       rreeppoo//pprroojjeecctt44//..ggiitt

       In this example, --pprruunnee prevents unnecessary descent  into  directories
       that  have  already  been  discovered  (for  example  we  do not search
       project3/src because we already found project3/.svn), but ensures  sib-
       ling directories (project2 and project3) are found.


EEXXIITT SSTTAATTUUSS
       ffiinndd  exits  with  status  0  if  all files are processed successfully,
       greater than 0 if errors occur.   This is  deliberately  a  very  broad
       description,  but  if the return value is non-zero, you should not rely
       on the correctness of the results of ffiinndd.


SSEEEE AALLSSOO
       llooccaattee(1), llooccaatteeddbb(5), uuppddaatteeddbb(1),  xxaarrggss(1),  cchhmmoodd(1),  ffnnmmaattcchh(3),
       rreeggeexx(7),  ssttaatt(2),  llssttaatt(2), llss(1), pprriinnttff(3), ssttrrffttiimmee(3), ccttiimmee(3),
       FFiinnddiinngg FFiilleess (on-line in Info, or printed).

HHIISSTTOORRYY
       As of findutils-4.2.2, shell metacharacters (‘*’, ‘?’ or ‘[]’ for exam-
       ple)  used  in filename patterns will match a leading ‘.’, because IEEE
       POSIX interpretation 126 requires this.

       The syntax --ppeerrmm ++MMOODDEE was deprecated in findutils-4.2.21, in favour of
       --ppeerrmm  //MMOODDEE.   As of findutils-4.3.3, --ppeerrmm //000000 now matches all files
       instead of none.

       Nanosecond-resolution timestamps were implemented in findutils-4.3.3.

       As of findutils-4.3.11, the --ddeelleettee action sets ffiinndd’s exit status to a
       nonzero  value when it fails.  However, ffiinndd will not exit immediately.
       Previously, ffiinndd’s  exit  status  was  unaffected  by  the  failure  of
       --ddeelleettee.

       Feature                Added in   Also occurs in
       -newerXY               4.3.3      BSD
       -D                     4.3.1
       -O                     4.3.1
       -readable              4.3.0
       -writable              4.3.0
       -executable            4.3.0
       -regextype             4.2.24
       -exec ... +            4.2.12     POSIX
       -execdir               4.2.12     BSD
       -okdir                 4.2.12
       -samefile              4.2.11
       -H                     4.2.5      POSIX
       -L                     4.2.5      POSIX
       -P                     4.2.5      BSD
       -delete                4.2.3
       -quit                  4.2.3
       -d                     4.2.3      BSD
       -wholename             4.2.0
       -iwholename            4.2.0
       -ignore_readdir_race   4.2.0
       -fls                   4.0
       -ilname                3.8
       -iname                 3.8
       -ipath                 3.8
       -iregex                3.8

NNOONN--BBUUGGSS
       $$ ffiinndd .. --nnaammee **..cc --pprriinntt
       find: paths must precede expression
       Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]

       This  happens  because  _*_._c has been expanded by the shell resulting in
       ffiinndd actually receiving a command line like this:

       ffiinndd .. --nnaammee bbiiggrraamm..cc ccooddee..cc ffrrccooddee..cc llooccaattee..cc --pprriinntt

       That command is of course not going to work.  Instead of  doing  things
       this  way, you should enclose the pattern in quotes or escape the wild-
       card:
       $$ ffiinndd .. --nnaammee ''**..cc'' --pprriinntt
       $$ ffiinndd .. --nnaammee \\**..cc --pprriinntt


BBUUGGSS
       There are security problems inherent in the behaviour  that  the  POSIX
       standard  specifies  for  ffiinndd,  which  therefore cannot be fixed.  For
       example, the --eexxeecc action is inherently insecure, and  --eexxeeccddiirr  should
       be used instead.  Please see FFiinnddiinngg FFiilleess for more information.

       The environment variable LLCC__CCOOLLLLAATTEE has no effect on the --ookk action.

       The  best  way  to  report  a  bug  is to use the form at http://savan-
       nah.gnu.org/bugs/?group=findutils.  The reason for  this  is  that  you
       will then be able to track progress in fixing the problem.   Other com-
       ments about ffiinndd(1) and about the findutils package in general  can  be
       sent  to  the _b_u_g_-_f_i_n_d_u_t_i_l_s mailing list.  To join the list, send email
       to _b_u_g_-_f_i_n_d_u_t_i_l_s_-_r_e_q_u_e_s_t_@_g_n_u_._o_r_g.



                                                                       FIND(1)
